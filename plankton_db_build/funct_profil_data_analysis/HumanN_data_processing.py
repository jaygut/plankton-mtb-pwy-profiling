import matplotlib.pyplot as plt
from matplotlib import cm
import seaborn as sns
import colorsys
from matplotlib.collections import PatchCollection


import Bio.SeqIO as bioseqio
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
#from Bio.Alphabet import IUPAC
from Bio import Entrez

from ete3 import NCBITaxa
from taxonomy_ranks import TaxonomyRanks

from subprocess import Popen, call, STDOUT, PIPE
import os
import shutil
import pandas as pd
import numpy as np
import matplotlib
import json
import glob
import re
import gzip
import sys
import csv
import time
import io
import pathlib
from collections import OrderedDict
import itertools

###Adding to sys.path the dir where pycircos is installed on my workstation
pycircos_path = '/home/VLIZ2000/jayson.gutierrez/anaconda3/envs/biobakery3/lib/python3.7/site-packages/pycircos/'
sys.path.append(pycircos_path)
from pycircos import Garc,Gcircle


###Utility functions
###PWY shorthand for metabolic pathway
def stack_pwy_dfs(fid_list):
    """Function to stack dfs (sample-wise) containing pathway abundance scores from humann"""
    new_df_cont = []
    for fid in fid_list:
        df = pd.read_csv(fid,sep='\t')
        if(df.shape[0] > 2):
            pwy_name_cont = []
            for i in df["# Pathway"]:
                if( ('UNMAPPED' not in i) and ('UNINTEGRATED' not in i)):
                    pwy_id = i.split('|')[0].split(':')[-1]
                    if(pwy_id not in pwy_name_cont):
                        pwy_name_cont.append(pwy_id)
            
            if(len(pwy_name_cont)>0):
                
                new_df = pd.DataFrame.from_dict({"Pathway":pwy_name_cont,
                                                 "Sample":df.columns[-1].split("_")[0]})
                new_df_cont.append(new_df)

    if(len(new_df_cont)>0):
        return pd.concat(new_df_cont)
    else:
        return pd.DataFrame.from_dict({"Pathway":[np.nan],"Sample":[np.nan]})

def make_pathway_wise_df(files_dir, db_type):
    """Function to create a df of genus-specifc metabolic pathways identified by humann using either custom or default DBs"""
    genus_cont = []
    pwy_name_cont = []
    for fid in files_dir: #custom_db_profiling | default_db_profiling:
        for i in pd.read_csv(fid,sep='\t')["# Pathway"].values:
            if(("s__" in i) and ("UNMAPPED" not in i) and ('UNINTEGRATED' not in i)):
                pwy, tax = i.split("|")
                genus = tax.split('.')[0].replace('g__','')
                pwy_name_cont.append(pwy)
                genus_cont.append(genus)
                
    pwys_list = list(map(lambda s:": ".join(s),zip(pwy_name_cont,genus_cont)))
    pwys_df = pd.DataFrame(data=pwys_list,columns=["Pathway"])
    pwys_df["DB-type"] = db_type #"Custom-DB" | "Default-DBs"
    
    return pwys_df

#Switch off warning
pd.set_option('mode.chained_assignment', None)
def reorganize_pwy_df(fid, db = "Custom"):
    '''Function to reorganize pathway abundance df'''
    pwy_df = pd.read_csv(fid,sep='\t')
    #Filter df
    pwy_df2 = pwy_df[(~pwy_df["# Pathway"].str.contains("UNMAPPED|UNINTEGRATED")) & (pwy_df["# Pathway"].str.contains("g__"))]
    #Get sampled ID
    sample_id = pwy_df.columns[1].split("_")[0]
    #Rename 2nd column
    pwy_df2.rename(columns={pwy_df.columns[1]:"Abundance"},inplace=True)
    #Split first colum into other columns (atomic descriptors)
    new_cols = pwy_df2["# Pathway"].apply(lambda s: s.split("|")[0].split(":")).values
    pwy_df2.rename(columns={"# Pathway":"Full_Pathway"},inplace=True)
    pwy_df2["Pathway_ID"] = [i[0] for i in new_cols]
    pwy_df2["Pathway_Name"] = [i[1][1:].capitalize() for i in new_cols]
    pwy_df2["Sample_ID"] = sample_id
#     pwy_df2["DB_Type"] = db
    return pwy_df2

def split_lbl(txt2split):
    '''Utility for splitting up col name'''
    pwy_id = txt2split.split(":")[0]
    pwy_name, tax_id = txt2split.split(": ")[1].split("|")
    return [pwy_id,pwy_name, tax_id]


def reshape_joint_pwy_abund_df(table_fid = "custom_humann_prof_results_1/joint_samples_path_abundance-cpm.tsv", 
                               sample_h = "SRR", sorted_cols=True, split_at='_'):
    '''Function that takes in the joint pwy abundance tables across samples analyzed (normalized to CPM), and
       returns a new DF with a shape more suitable for downstream plotting/analysis.
       NOTE: the input table can be generated from per-sample pathwayabundance.tsv files generated by humann, as follows:
       
       - humann_join_tables -i ${TABLES_DIR} -o ${TABLES_DIR}/joint_samples_path_abundance.tsv --file_name pathabundance
       - humann_renorm_table -i ${TABLES_DIR}/joint_samples_path_abundance.tsv -o ${TABLES_DIR}/joint_samples_path_abundance-cpm.tsv --units cpm --update-snames
    '''
    pwy_df = pd.read_csv(table_fid, sep="\t")
    #Remove entries matching given patterns
    pwy_df2 = pwy_df[(~pwy_df["# Pathway"].str.contains("UNMAPPED|UNINTEGRATED")) & (pwy_df["# Pathway"].str.contains("g__"))]
    if(sorted_cols):
        #Sort sample IDs
        sorted_sids = sorted(pwy_df2.columns[1:], key = lambda s: int(s.split("_")[0].replace(sample_h,"")))
        #Create another DF
        pwy_df3 = pd.concat([pwy_df2['# Pathway'], pwy_df2[sorted_sids]], axis=1)
    else:
        pwy_df3 = pwy_df2
    #Melt df down and rename cols
    full_pwys = pwy_df3['# Pathway'].values
    short_sids = [s.split(split_at)[0] for s in pwy_df3.columns[1:]]
    pwy_df3.rename(columns=dict(zip(pwy_df3.columns[1:],short_sids)), inplace=True)
    pwy_df3 = pwy_df3.melt(id_vars="# Pathway")
    #Modify col names
    pwy_df3.rename(columns={"# Pathway":"Full_Pathway", "variable":"Sample_ID", "value":"Abundance"}, inplace=True)
    #Create another set of features to merge previous df with
    pwy_df31 = pd.DataFrame(np.array(pwy_df3["Full_Pathway"].apply(split_lbl).values.tolist()),
                            columns=["Pathway_ID","Pathway_Name","TaxID"])
    #Return DF in desired form
    return pd.concat([pwy_df3,pwy_df31],axis=1)


def get_sps_wise_pwy_activity_df(custom_db_pwy_abund_df, sid='A4', mean_pwy_abund_thr=1, max_pwy_abund_thr=1, log_transf=True):
    '''Function that takes in the custom_db_pwy_abund_df (generated by the funtion reshape_joint_pwy_abund_df) and returns 
       a sample-specific df with taxa as rows and active metabolic pathways as columns. Based on this df, one can create
       a heatmap to examine the full metabolic profile of individual species in a community. 
       Also, this df can be thought of as a features matrix that could be used to feed ML models to classify samples based on
       metabolic pathway activity profiles.
    '''
    
    #Enumerate unique metabolic pathways and taxa
    sample_ids_list = custom_db_pwy_abund_df["Sample_ID"].unique()
    enum_dist_taxids = custom_db_pwy_abund_df["TaxID"].unique()
    enum_dist_pwys = custom_db_pwy_abund_df["Pathway_Name"].unique()

    if(sid in sample_ids_list):
        #Loop over each metabolic pathway identified by humann as a hit, and choose whether or not to include a given pwy in the analysis
        #based on e.g. averageabundance across all the samples considered
        avrg_pwy_abund_cont = []
        for query_pwy in enum_dist_pwys:
            #Calculate average pwy abundance across all the samples under study
            avrg_pwy_abund = custom_db_pwy_abund_df[custom_db_pwy_abund_df["Pathway_Name"]==query_pwy]["Abundance"].mean()
            avrg_pwy_abund_cont.append(avrg_pwy_abund)

        #Set threshold for discriminating pwy abundance based on mean abundance
        avrg_pwy_abund_df = pd.DataFrame(data=avrg_pwy_abund_cont, 
                                         columns=["Avg_PWY_Abund"], 
                                         index=enum_dist_pwys).sort_values(by="Avg_PWY_Abund",ascending=False)

        #Filtering full list of metabolic pwys that humann initially returned as hits
        enum_dist_pwys_filtered = avrg_pwy_abund_df[avrg_pwy_abund_df>mean_pwy_abund_thr].dropna().index.values

        #Loop over each taxonomic group returned by humann as a hit, and choose whether or not to include a given tax in the analysis
        #based on e.g. max pwy abundance observed across all the samples considered
        max_pwy_abund_cont = []
        for query_taxid in enum_dist_taxids:
            #Calculate average pwy abundance across all the samples under study
            max_pwy_abund = custom_db_pwy_abund_df[custom_db_pwy_abund_df["TaxID"]==query_taxid]["Abundance"].max()
            max_pwy_abund_cont.append(max_pwy_abund)

        #Set threshold for discriminating taxID based on max pwy abundance
        max_pwy_abund_df = pd.DataFrame(data=max_pwy_abund_cont, 
                                        columns=["Max_PWY_Abund"], 
                                        index=enum_dist_taxids).sort_values(by="Max_PWY_Abund",ascending=False)

        enum_dist_taxids_filtered = max_pwy_abund_df[max_pwy_abund_df>max_pwy_abund_thr].dropna().index.values

        #Set features matrix nxm, with n = num taxids and m = num unique pwys
        nrs = len(enum_dist_taxids_filtered)
        ncs = len(enum_dist_pwys_filtered)
        feats_mat = np.zeros((nrs,ncs))

        #Loop over full DF an fill in the entries corresponding to a sample-specific feats matrix
        #Get df corresponding to a given sample
        sample_wise_df = custom_db_pwy_abund_df.query("Sample_ID=='{}'".format(sid))
        for (row,txid) in enumerate(enum_dist_taxids_filtered):
            #Get pwy data for a given taxid in current sample
            pwy_data4txid = sample_wise_df[sample_wise_df["TaxID"]==txid]
            #Fill the appropriate column-wise entries
            if(len(pwy_data4txid)>0):
                for j in pwy_data4txid[["Pathway_Name","Abundance"]].iterrows():
                    try: 
                        get_pwy = j[1][0]
                        idx = np.where(enum_dist_pwys_filtered==get_pwy)[0][0]
                        get_abund = j[1][1]
                        feats_mat[row,idx] = get_abund
                    except:
                        pass

        #Put together df used to 
        sample_wise_feats_df = pd.DataFrame(data=feats_mat, 
                                            columns=enum_dist_pwys_filtered, 
                                            index=enum_dist_taxids_filtered)

        #Sort rows (species) by mean pwy abundance observed in a given sample
        sample_wise_feats_df = sample_wise_feats_df.loc[sample_wise_feats_df.mean(axis=1).sort_values(ascending=False).index]

        if(log_transf):
            return (sample_wise_feats_df + 1).apply(np.log)
        else:
            return sample_wise_feats_df
        
    else:
        print("Sample: {} does not exist in the query DF!".format(sid))
        

def generate_circos_plot(custom_db_pwy_abund_df, samples_corr_df, corr_coeff_thr = 0.7, 
                         dim = 0, width_circos = (500, 999), max_num_intervs2plot = 60, 
                         output_fig_name = 'figures/circos_heatmap_row-taxa_pwys-cols_abund_chords.png',
                         mean_pwy_abund_thr=1, max_pwy_abund_thr=1, log_transf=True, garc_size = 100):
    
    """Function to generate a circos plot from the DF of taxon-specific metabolic pwys profile across different samples.
       
       Parameters:
       - custom_db_pwy_abund_df (see above), a DF computed through the application of HumanN3, with the following columns:
         ['Full_Pathway', 'Sample_ID', 'Abundance', 'Pathway_ID', 'Pathway_Name','TaxID']
       - samples_corr_df: correlation matrix of total metabolic pathway abundances across all the species identified across samples
       - All the other parameters are to adjust the rendering of the circos plot as explained in the library pycircos.py 
         (https://github.com/ponnhide/pyCircos)
    """


    #Instantiate main classes to create circos plot
    gcircle = Gcircle()

    #List sample IDs in DF above
    sids_list = custom_db_pwy_abund_df["Sample_ID"].unique()

    #Get the number of rows (taxa) each sample-specific df contains. NOTE: each sample is associated to a DF with exactly the same dimesions n x m
    query_sid = sids_list[0] #Pick only one sample to assess the dimensions of the DF
    nrows, ncols = get_sps_wise_pwy_activity_df(custom_db_pwy_abund_df, 
                                                sid=query_sid, 
                                                mean_pwy_abund_thr=mean_pwy_abund_thr, 
                                                max_pwy_abund_thr=max_pwy_abund_thr, 
                                                log_transf=log_transf).shape

    #Set dim along which to display heatmap
    if(dim==0):
        #width_circos = (700, 999)
        splits = np.linspace(*width_circos, nrows+1)
        #output_fig_name = 'figures/circos_heatmap_row-taxa_pwys-cols_abund_chords.png'
        #max_num_intervs2plot = 60 #Max num taxa, or rows in reshaped_joint_samples_path_abundance-cpm.tsv = 65
    else:
        #width_circos = (100, 999)
        splits = np.linspace(*width_circos, ncols+1)
        #output_fig_name = 'figures/circos_heatmap_row-pwys_taxa-cols_abund_chords.png'
        #max_num_intervs2plot = 22 #Max num rows, or pwys, in transposed reshaped_joint_samples_path_abundance-cpm.tsv = 22

    intervs_list = [tuple(splits[i : i + 2]) for i in range(0, len(splits), 1)][:-1][::-1][:max_num_intervs2plot]

    ##Make circle to create sectors for each sample
    for sid in sids_list:
        #Making the len of the arc to be proportional to total metabolic pathway abundance observed in a given sample
        #weight = custom_db_pwy_abund_df[custom_db_pwy_abund_df["Sample_ID"]==sid]["Abundance"].sum()
        arc = Garc(arc_id=sid, 
                   size=garc_size, 
                   interspace=3, 
                   raxis_range=(900,1010),#(990,1000), 
                   labelposition=60, 
                   label_visible=True, 
                   edgecolor="white")
        gcircle.add_garc(arc) 

    gcircle.set_garcs()

    #-----------------------------------------------------
    #Loop over sample-specific DFs and plot corresponding data at a given arc/sector in the circos plot
    for i,rv in enumerate(intervs_list):
    #     print("Adding row #:{} spanning {}".format(i,rv))
        for sid in sids_list:
            scaled_sample_wise_feats_df = get_sps_wise_pwy_activity_df(custom_db_pwy_abund_df, 
                                                                       sid=sid, 
                                                                       mean_pwy_abund_thr=mean_pwy_abund_thr, 
                                                                       max_pwy_abund_thr=max_pwy_abund_thr, 
                                                                       log_transf=log_transf)
            if(dim==0):
                data_struct = scaled_sample_wise_feats_df.values[i].tolist() #rows as taxa and cols as pwys
            else:
                data_struct = scaled_sample_wise_feats_df.values[:,i].tolist() #rows as pwys and cols as taxa

            #This if statement is required to avoid an exception in the source code: pycircos.py
            if(max(data_struct) == min(data_struct)):
                vmax = max(data_struct) + 0.01
            else:
                vmax = max(data_struct)

            vmin = min(data_struct)

            #data_struct = scaled_sample_wise_feats_df.sum(axis=1).values.tolist()
            gcircle.heatmap(garc_id=sid, 
                            data=data_struct, 
                            raxis_range=rv, 
                            vmin=vmin, 
                            vmax=vmax, 
                            cmap=plt.cm.YlOrRd)


    #List number of unique pairs
    sample_pairs = list(combinations(sids_list, 2))
    #Get positions for each pair
    rce_pairs = [[np.where(i==sids_list)[0][0] for i in entry] for entry in sample_pairs]

    #Coordinates to place the chords/edges
    s,e = (garc_size*0.475, garc_size*0.525)

    #Loop over pairs of samples and draw a chord/link whenever a relatively strong correlation exists
    for (n,sp) in enumerate(sample_pairs):
        rix, cix = rce_pairs[n]
        lbl1, lbl2 = [sids_list[i] for i in rce_pairs[n]]
    #     s,e = np.array(sid2coords[lbl1])*15
        source = (lbl1, s,e, intervs_list[-1][0])
    #     s,e = np.array(sid2coords[lbl2]) 
        destinat = (lbl2, s,e, intervs_list[-1][0])
        corr_coeff = samples_corr_df.iloc[rix, cix]
        if(corr_coeff>0):
            fc = 'blue'
        else:
            fc = 'red'
        if(abs(corr_coeff)>=corr_coeff_thr):
            gcircle.chord_plot(source, destinat, 
                               facecolor=fc, 
                               linewidth=0, 
                               #edgecolor=ec
                              )

    #gcircle.figure
    gcircle.figure.savefig(output_fig_name, dpi=900, bbox_inches='tight', pad_inches= 0.2, facecolor='w')